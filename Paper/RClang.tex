\documentclass[article]{jss}
\usepackage{comment}
\usepackage{graphicx}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% almost as usual
\author{Duncan Temple Lang\\University of California at Davis}
\title{RCIndex: Accessing C/C++ Code in R with libclang}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Duncan Temple Lang}
\Plaintitle{RCIndex: Accessing C/C++ Code in R with libclang}
\Shorttitle{RCIndex}

%% an abstract and keywords
\Abstract{ 
  The ability to get information about \C/\Cpp{} code routines
  and data structures can allow us to do many things in an intrepreted
  language such as \R.  We use \libclang{}, a flexible, embeddable
  library, to develop \R{} functionality to obtain information about
  native code.  We describe the \Rpkg{RCIndex} package which provides
  high-level functionality to access this information and also
  lower-level approaches to query and manipulate other aspects of
  native code.  We describe how to use the package and scenarios in
  which it is useful.
  This functionality is infrastructural and not necessarily of
  direct use or interest to end-users.
} 
\Keywords{\R, \Rpkg{RCIndex} package}
\Plainkeywords{R, RCIndex} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Duncan Temple Lang\\
  4210 Math Sciences Building, \\
  University of California at Davis \\
  One Shields Avenue\\
  Davis, CA 95616\\
  E-mail: \email{duncan@r-project.org}\\
  URL: \url{http://www.omegahat.org}
}


\usepackage[T1]{fontenc} 
\catcode`\_=12

\def\C{\proglang{C}}
\def\perl{\proglang{PERL}}
\def\Cpp{\proglang{C$++$}}
\def\Java{\proglang{Java}}
\def\Python{\proglang{Python}}
\def\R{\proglang{R}}
\def\llvm{\proglang{LLVM}}
\def\Rpkg#1{\pkg{#1}}
\def\Rfunc#1{\textsl{#1()}}
\def\Rop#1{\texttt{#1}}
\def\Rvar#1{\textsl{#1}}
\def\Rel#1{\textbf{#1}}
\def\Cfunc#1{\textit{#1()}}
\def\Cvar#1{\textit{#1}}
\def\file#1{\textbf{#1}}
\def\Ctype#1{\texttt{#1}}
\def\Rclass#1{\textit{#1}}
\def\Rslot#1{\textbf{#1}}
\def\Rarg#1{\textbf{#1}}
\def\Roption#1{\dquote{\textsl{#1}}}
\def\Cppkeyword#1{\textbf{#1}}
\def\Ckeyword#1{\textbf{#1}}
\def\Cexpr#1{\textsl{#1}}
\def\Rexpr#1{\textit{#1}}

\def\Rtrue{TRUE}
\def\Rfalse{FALSE}

\def\libclang{\textbf{libclang}}
\def\clang{\textbf{clang}}
\def\gcc{\textit{GCC}}
\def\XML{\textit{XML}}

\def\dquote#1{``#1''}

\def\ShFlag#1{\textit{#1}}

\def\ClangKind#1{\textit{#1}}
\def\ClangTypeKind#1{\textsl{#1}}

\DefineVerbatimEnvironment{RCode}{Verbatim}{fontshape=sl}
\DefineVerbatimEnvironment{CCode}{Verbatim}{fontshape=tt}
\DefineVerbatimEnvironment{ShCode}{Verbatim}{fontshape=it}
\DefineVerbatimEnvironment{ROutput}{Verbatim}{fontshape=bf}

\begin{document}

\section{Motivation}\label{sec:Introduction}

We typically think of \C{} and \Cpp{} code as something we write,
compile and call. It is rarely the input to anything but the compiler.
However, such code is a source of potentially useful information that
we can use in statistical and scientific computing.  In order to
leverage this information, we need to be able to access it in a
structured manner in a form that we can compute on and in the
programming environment in which we want to use it.
\libclang{}~\cite{bib:libclang,bib:libclangSlides} has
emerged as a powerful, industrial-strength library that provides
valuable functionality for working with \C/\Cpp{} source code and that
we can embed in \R (and many other languages).

There are several applications of being able to programmatically
understand \C/\Cpp{} code.

\textbf{Registering \R-callable routines}: When we write \C/\Cpp code
to use in an \R{} package, it is useful to explicitly register the
routines that we can call via any of the
\Rfunc{.C}/\Rfunc{.Call}/\Rfunc{.External} interfaces.  When the
routines are registered, \R{} can help to identify potential errors in
calling them.  \R{} can detect an incorrect number of arguments for a
routine, or that the types are incorrect, e.g. an integer vector when
a numeric vector is expected. Registration also allows us to resolve
the symbols just once rather than each time we call a routine, and it
also allows us to use different symbols to refer to the routines.  It
is convenient to be able to run \R{} code to identify the \R-callable
routines and to generate the registration information
programmatically.  As we change these routines, we can update the
registration information with little effort and ensure the information
is synchronized.


\textbf{Generating bindings to native libraries}: Numerous \R{}
packages provide interfaces to existing \C/\Cpp{} libraries.  This
typically involves manually creating an \R-callable wrapper routine
for each routine of interest in the third-party library and also a
corresponding \R{} function that invokes the wrapper routine, having
coerced the \R{} arguments to the appropriate form.  This is often
quite straightforward, but both time-consuming and error-prone.  This
makes for unnecessarily lengthy write-debug-test cycles.  Instead,
we'd like to be able to programmatically read the information about
the third-party routines and data types and generate the wrapper
routines and \R{} functions without human intervention, or at least
minimal, generic intervention.  If we could generate these
``bindings'' programmatically, the \R{} programmer can spend time
creating higher-level functionality using these primitives.

\textbf{Dynamic calls to native routines}: The
\Rpkg{rdyncall}~\cite{bib:rdyncall} and \Rpkg{Rffi}~\cite{bib:Rffi}
\R{} packages avoid having to explicitly create the wrapper routines
and \R{} functions to interface to existing \C{} routines. Instead,
they both provide a dynamic mechanism to call arbitrary native
routines.  However, both approaches require a description of the
target routines.  Again, we want to obtain this information
programmatically and then we can easily generate these descriptions
and remove humans from the process.

\textbf{Understanding third-party libraries interactively}: When we
interface to third-party libraries, we typically read documentation to
identify and understand the important routines and data structures.
In some situations, it can be convenient to find this information
interactively within an environment such as \R.  Rather than reading
static document, we can query the code for information such as how
often a particular data type is returned by a routine or passed as an
argument? or what idioms does the library use?  We can use \R's
graphics capabilities to visualize the code and which routines call
which other routines.

%documentation in comments - see RCUDA.
\textbf{In-line documentation as comments}: Often third-party native
libraries contain document in comments adjacent to the corresponding
routines and data structures.  It is convenient to be able to easily
access this documentation and potentially reuse it as \R{}
documentation for functions that interface to the routines, as we did
for the \Rpkg{RCUDA} package (\url{http://github.com/duncantl/RCUDA}).

\textbf{Compiling \R{} code}: Recently, we have been developing \R{}
facilities for compiling \R{} code to native instructions to by-pass
the \R{} interpreter.  This allows us to rewrite and translate \R{}
code so that it is essentially native code and can call other existing
native routines, for example, in the \R{} engine or standard \C{}
libraries.  This results in significant speedup.  However, to make
this work, we need to know the signature -- parameter types and return
type -- of these native routines.  Again, if we can find these
programmatically, we greatly simplify and improve the entire process
of generating the code.

\textbf{Determining memory management and mutability of inputs and
  outputs}: When we call existing native routines, we often want need
to know whether we are in charge of the memory for the inputs or
whether the called routine is responsible.  Often, programmers omit
important information about whether a parameter is modified within a
routine or if it is constant.  This is important information as it
allows us to differentiate between an array of values passed as a
pointer, or a scalar whose contents are changed.  We would like to be
able to analyze the body of the routine to be able to determine if and
how it modifies its parameters so that we can avoid making copies of
data, if possible.


\textbf{Software as Data}: While we may not think of code as data,
analyzing software is an important field.  Software defines several
networks related to i) which routines call which other routines, ii)
the hierarchical structure of \Cpp{} classes, iii) which files
\texttt{\#include} other files, and so on.  We can find which
global/non-local variables are used in which routines to help identify
problems with parallelization and potential refactorzation of the
code.  We can combine this data with version control history to better
understand software projects.


\textbf{Detecting errors in native code for \R}: \R's package
mechanism provides a powerful set of tests and checks to potential
errors in \R{} code.  These are very useful and can identify errors
such as misspelled variable or function names before the code is run.
It would be valuable to perform similar tests on \C{} code in \R{}
packages.  We might identify common issues such as not protecting
allocated \R{} objects from garbage collection.  We could do this by
analyzing uses of \Cfunc{PROTECT} and \Cfunc{UNPROTECT} calls and
ensuring there is an appropriate correspondence.  These are
\R-specific checks and will not be done by other code-analyzing
software.


We can also find ``dead'' routines that are never called by other
routines and so help to reduce the code.

We hope these applications motivate the utility of being able to
navigate native code in \R and indicate that there are many more.  In
this paper, we describe how to use the \R{} interface to \libclang.
We start in section~\ref{sec:Whylibclang} by comparing \libclang{}
with other approaches we and others have pursued.  We then describe
the fundamental concepts of \libclang{} in
section~\ref{sec:libclangConcepts}.  We follow this in
section~\ref{sec:RCIndex} by discussing the \R{} interface





% This could come after the high-level material, but it may make sense here.
\input{clangConcepts}

\section[The RCIndex package]{The \Rpkg{RCIndex} package}\label{sec:RCIndex}
The \Rpkg{RCIndex} provides numerous high-level functions that return
information about \C{} code.  These refer to functions that I have
developed building on the lower-level tools and which users can call
directly to get useful information or to perform high-level tasks such
as generating registration information or getting all the routines or
\Cpp{} classes. These might be initial steps in a higher-level task,
but they are high-level relative to the primitive functions in
the \Rpkg{RCIndex} package with which we implemented these functions.

\subsection{High-level Functionality}

% Talk about filtering based on the file name. (Implement this
% consistently).  Mention can do it afterwords or during the collection.

We might consider functions that take a source file and extract one or
more of the types of top-level elements in that file, e.g. routines,
data structures, enumeration definitions, \Cpp{} class definitions as
the very highest-level functions.  The \R{} user can call these
functions with just the name of the file and perhaps additional
arguments for the parser and the results are returned.  The user
doesn't have to write any code to manipulate or traverse the parse
tree (AST).  She doesn't have to necessarily create a translation unit
before calling one of these functions. As such, they are ``atomic''.
(There are occasions, however, when it is beneficial to create a
translation unit and traverse that several times to extract different
information on each traversal.)

The \Rfunc{getRoutines} does as its name suggests. It takes a file
name or an existing translation unit object and returns a list with an
element for each routine declaration or definition in the code.  Each
element contains the \Rclass{CXCursor} object representing the
routine, a list of the parameters giving their name and data types,
and the return type.  This is currently an S3 object of class
\Rclass{FunctionDecl}. Since this contains the cursor, we can query it
for the name of the routine, the file in which it is located, the
location in that file and so on. In other words, information that
we don't explicitly collect into the \R{} object can be determined
later when we use this description of the routine.

\Rfunc{getEnums} returns a list of the enumeration definitions in a
source file. Each element is an instance of the S4 class
\Rclass{EnumerationDefinition}.  Like the \Rclass{FunctionDecl} class,
this contains a reference to the definition in case we want to query
it further at a later time.  The actual values in the enumeration are
stored in the \Rslot{values} slot as a named integer vector.  The
names are the symbolic names we should use, while the values are the
literal values to which these names correspond.  These values allow us
to cross the interface between \R{} and native code where there is no
existing  association between the symbolic names.

\Rfunc{getDataStructures} returns a list of the data types defined in
a source file.


\Rfunc{getGlobalVariables} yields references to all of the non-local
variables within a source file.  From this, we have their names and
types.

\Rfunc{getCppClasses} traverses a translation unit, either pre-parsed
or a source file, and constructs a description for each of the \Cpp{}
classes it contains. Each class description is an instance of the
class \Rclass{C++Class}, with template classes using the derived class
\Rclass{TemplateC++Class}.  A class description contains the name of
the class, a list of its fields and another for its methods, and
references to the base/super class cursors.  The fields and methods
each have their type information and also the accessor qualifier,
i.e. \Cppkeyword{private}, \Cppkeyword{protected} or
\Cppkeyword{public}.



The \Rfunc{findCalls} function takes a cursor -- typically either a
routine or an entire translation unit -- and finds the names of
routines in any call.  This allows us to determine which routines call
which other routines and so describe a graph/network.  We can then
discover potentially interesting things about the routines.  For
example, we might look at just the routines within a single file and
see which of these call other routines in the file and which are
called by other routines in the file.  This might identify isolated
routines that don't necessarily belong in this particular file. It
might also help us to understand how the the routines interact.
We can use the \Rpkg{igraph} and \Rpkg{graph} packages to perform
computations on the network and also to visualize it.

We'll show how to do this on a file \file{memory.c} in the \R{}
interpreter's source.
We start by obtaining the routines from the file:
\begin{RCode}
f = sprintf("%s/../src/main/memory.c", R.home())
r = getRoutines(f, TRUE, args = "-DHAVE_CONFIG_H",
                  includes = c(sprintf("%s/../src/include", R.home()),
                               sprintf("%s/include", R.home())))
\end{RCode}
We'll discuss the extra arguments in section~\ref{sec:BuildingBlocks}

For each of these routines, we find which routines they call with
\begin{RCode}
kalls = lapply(r, findCalls)
\end{RCode}
To restrict the routines to only those within this file
and create the adjacency matrix, we use 
\begin{RCode}
withinFileCalls = lapply(kalls, intersect, names(r))    
m = matrix(0, length(r), length(r), dimnames = list(names(r), names(r)))
invisible(sapply(names(withinFileCalls), 
           function(id) 
              m[id,  withinFileCalls[[id]]] <<- 1))
i = rowSums(m) == 0 & colSums(m) == 0
m = m[!i, !i]
\end{RCode}
The final two lines discard the routines which are neither called or
call any other routines.
% We could do this more elegantly.
Finally, we can draw the graph
\begin{RCode}
library(igraph)
g = graph.adjacency(mm, "directed")       
plot(g, vertex.size = 2, vertex.label.cex = .6, edge.arrow.size = .5)
\end{RCode}
and it is displayed in figure~\ref{fig:callgraph}.

\begin{figure}
\includegraphics{callgraph.pdf}
\caption{A display of the call graph for the file \file{memory.c} in
  \R's source. This displays which routines call which other routines
  within just that file. The clusters and important nodes become evident.}
  \label{fig:callgraph}
\end{figure}


\subsection[Registering R-callable routines]{Registering \R-callable routines}

\subsection{Building Blocks}\label{sec:BuildingBlocks}

\Rfunc{createTU}

\input{writingVisitorFunctions}




\section{Extended Examples and Applications}
In this section, we explore some more advanced examples of how to use
the \Rpkg{RCIndex} package to get different information from a
translation unit.  One of the best sources of such examples is the set
of high-level functions in the package itself,
e.g. \Rfunc{getRoutines}, \Rfunc{getCppClasses}.  We have used the
generator function and lexical scoping approach to implement a set of
collector functions that gather the different types of information we
want.

In section~\ref{sec:Introduction}, we provided numerous motivating
applications of being able to process native code.  We will present
partial/heuristic approaches to some of these.  One aim of these
examples is to illustrate how to traverse the translation unit and
sub-cursors and work on the structure of the information.  Another aim
is to illustrate how to work with \libclang's type system.

\input{protect}

\input{rffi}

\input{mutability}

%%%%%%%%%%%%%%%%%%%%%

\input{whyClang}


\section{Future Work}

We have created bindings for most of the facilities provided by
\libclang.  However, we have ignored the code-completion routines and
the various indexing facilities.  Now that we have the basic tools
provided by \Rpkg{RCIndex} in \R, we can programmatically generate
bindings to these routines. 

Given these basic bindings, we plan to develop additional high-level
functionality to process different aspects of native code. We are
interested in processing the bodies of the routines to understand
their characteristics.

While not exclusively related to \Rpkg{RCIndex},
we are experimenting with ways to 

\bibliography{rclang}


\end{document}
